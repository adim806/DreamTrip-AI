/**
 * Utilities for generating detailed trip itineraries
 */

import { GoogleGenerativeAI } from "@google/generative-ai";

/**
 * Generates a structured prompt for trip itinerary creation
 * @param {Object} tripDetails - The complete trip details
 * @returns {string} - A formatted prompt for the AI model
 */
export const generateItineraryPrompt = (tripDetails) => {
  if (!tripDetails) {
    return "Please provide trip details to generate an itinerary.";
  }

  // Extract key data from trip details
  const {
    vacation_location,
    duration,
    dates,
    constraints = {},
    preferences = {},
    notes,
  } = tripDetails;

  // Calculate today's date in YYYY-MM-DD format
  const today = new Date().toISOString().split("T")[0];

  // Calculate if this is a current/upcoming trip or a future trip
  let tripTiming = "Planned for the future";
  if (dates?.from) {
    const tripDate = new Date(dates.from);
    const currentDate = new Date();
    const diffTime = tripDate - currentDate;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    if (diffDays <= 7) {
      tripTiming = "Coming very soon (within a week)";
    } else if (diffDays <= 30) {
      tripTiming = "Coming soon (within a month)";
    }
  }

  // Convert budget level to standardized format
  let standardizedBudget = "Not specified";
  if (constraints.budget) {
    if (
      constraints.budget.toLowerCase().includes("budget") ||
      constraints.budget.toLowerCase().includes("low") ||
      constraints.budget.toLowerCase().includes("cheap")
    ) {
      standardizedBudget = "Budget/Economy";
    } else if (
      constraints.budget.toLowerCase().includes("moderate") ||
      constraints.budget.toLowerCase().includes("medium") ||
      constraints.budget.toLowerCase().includes("standard")
    ) {
      standardizedBudget = "Moderate/Standard";
    } else if (
      constraints.budget.toLowerCase().includes("luxury") ||
      constraints.budget.toLowerCase().includes("high") ||
      constraints.budget.toLowerCase().includes("premium")
    ) {
      standardizedBudget = "Luxury/Premium";
    } else {
      standardizedBudget = constraints.budget;
    }
  }

  // Build a structured prompt for the AI in English
  let prompt = `Create a sleek, minimalist travel itinerary for:

DESTINATION: ${vacation_location || "Not specified"}
DURATION: ${duration || "Not specified"} days
DATES: ${dates?.from ? `${dates.from} to ${dates.to}` : "Not specified"}
BUDGET: ${standardizedBudget}
`;

  if (constraints) {
    if (constraints.travel_type) {
      prompt += `\nTRAVEL TYPE: ${constraints.travel_type}`;
    }
    if (constraints.preferred_activity) {
      prompt += `\nPREFERRED ACTIVITIES: ${constraints.preferred_activity}`;
    }

    if (
      constraints.special_requirements &&
      constraints.special_requirements.length > 0
    ) {
      prompt += `\nSPECIAL REQUIREMENTS: ${constraints.special_requirements.join(
        ", "
      )}`;
    }
  }

  if (preferences) {
    if (preferences.hotel_preferences) {
      prompt += `\nACCOMMODATION PREFERENCES: ${preferences.hotel_preferences}`;
    }
    if (preferences.dining_preferences) {
      prompt += `\nDINING PREFERENCES: ${preferences.dining_preferences}`;
    }
    if (preferences.transportation_mode) {
      prompt += `\nTRANSPORTATION: ${preferences.transportation_mode}`;
    }
  }

  if (notes) {
    prompt += `\nADDITIONAL NOTES: ${notes}`;
  }

  // Add specific requests for the itinerary style and format
  prompt += `
\nCreate a modern, elegant, minimalist itinerary with:

STYLE REQUIREMENTS:
- Use ### for day headings (smaller headings) instead of ## or #
- Each day should be compact and visually appealing
- Use emoji icons to represent activities (üèõÔ∏è for museums, üçΩÔ∏è for restaurants, etc.)
- Use **bold** to highlight venue names
- Format time and location info in a consistent, clean style
- Keep all content concise with minimal words

FOR EACH DAY, INCLUDE JUST:
- Day heading: "### Day X: Brief Theme (Date)" with date in parentheses
- Brief daily overview (1-2 lines) explaining the daily focus/area
- 2-3 main activities/attractions with emoji icon, including:
  * Name in **bold**
  * Time recommendation
  * 1-2 short sentences about what makes it special
  * Any special notes (cost, booking needs)
- 1 lunch recommendation with emoji icon, including:
  * Name in **bold**
  * Type of cuisine
  * Brief note about atmosphere or signature dish
- 1 dinner recommendation with emoji icon, including:
  * Name in **bold**
  * Type of cuisine
  * Brief note about atmosphere or signature dish
- Hotel/accommodation info when changing locations (one line)

FORMATTING:
- Use bullet points (not numbers) for all items
- Include small emoji icons before each type of activity
- Keep descriptions concise but informative (10-15 words maximum)
- No lengthy paragraphs or explanations
- Consistent spacing and clean layout throughout
- Add timeframe suggestions (morning/afternoon/evening)
`;

  // Add special requests based on trip details
  if (
    constraints.budget &&
    constraints.budget.toLowerCase().includes("budget")
  ) {
    prompt +=
      "\nInclude cost indicators like $ (budget), $$ (moderate) or $$$ (expensive) for restaurants and attractions.";
  }

  if (constraints.special_requirements) {
    if (constraints.special_requirements.includes("Kid-Friendly")) {
      prompt += "\nMark kid-friendly places with üë∂ emoji.";
    }
    if (
      constraints.special_requirements.includes("Accessible for Disabilities")
    ) {
      prompt += "\nMark accessible places with ‚ôø emoji.";
    }
  }

  // Add request for simplified additional sections
  prompt += "\nAt the end, include three VERY brief sections:";
  prompt += "\n- 'Backup Options' (3-4 bullet points with emoji icons)";
  prompt += "\n- 'Essential Tips' (3-4 bullet points with emoji icons)";
  prompt += "\n- 'Hidden Gems' (2-3 bullet points with emoji icons)";

  return prompt;
};

/**
 * Generates a detailed itinerary based on trip details
 * @param {Object} tripDetails - The complete trip details
 * @returns {Promise<Object>} - The generated itinerary or error object
 */
export const generateItinerary = async (tripDetails) => {
  try {
    console.log("Generating itinerary for:", tripDetails);

    // Create the AI model with specialized system instruction for itinerary generation
    const genAI = new GoogleGenerativeAI(
      import.meta.env.VITE_GEMINI_PUBLIC_KEY
    );
    const model = genAI.getGenerativeModel({
      model: "gemini-2.0-flash",
      systemInstruction: `
    You are a modern travel planner specializing in sleek, minimalist travel itineraries.
    Your task is to create a visually elegant itinerary that's brief yet informative.

    ## Modern Minimalist Style Guidelines:
    
    1. **Typography and Structure**: 
       - Use ### for day headings (smaller, more elegant headings)
       - Use consistent spacing between sections
       - Create visual hierarchy with minimal formatting
       - Keep line length short and readable

    2. **Visual Elements**:
       - Use emojis as visual indicators (üèõÔ∏è attractions, üçΩÔ∏è restaurants, üè® hotels, üö∂ walking)
       - Bold only the names of specific venues
       - Maintain clean, consistent formatting throughout
       - Use white space effectively

    3. **Content Philosophy**:
       - Balanced brevity - enough detail to be useful without overwhelming
       - Focus on what makes each place special or unique
       - Include practical details (opening times, cost indicators)
       - Skip obvious or generic information

    4. **Day Structure** (always in this order):
       - Day heading: "### Day X: Theme (Date)" - small and elegant
       - 1-2 line daily overview explaining the focus/neighborhood
       - 2-3 main attractions/activities with emoji icon (include brief descriptions)
       - Lunch recommendation with emoji icon (include cuisine type and brief note)
       - Dinner recommendation with emoji icon (include cuisine type and brief note)
       - Hotel information (only when relevant) with emoji icon

    ## Example Format:
    
    ### Day 1: Old Town Discovery (June 15)
    
    Explore the historic center's charming cobblestone streets and architectural highlights.
    
    - üèõÔ∏è **British Museum** (10:00-13:00) - World-class ancient artifacts spanning civilizations. Free entry, photography allowed.
    - üçΩÔ∏è **Dishoom** - Modern Indian street food in vintage Bombay-style caf√©. Try the house black daal.
    - üè¢ **Tower of London** (14:30-17:00) - Historic fortress housing crown jewels and royal armory. Book tickets online to skip lines.
    - üç∑ **Barrafina** - Upscale Spanish tapas bar with counter seating. Known for seafood and Spanish wines.
    - üè® **The Hoxton** - Stylish boutique hotel with comfortable beds and excellent lobby workspace.

    ### Essential Tips
    
    - üí≥ Museums free on Sundays, book online to skip queues
    - üöá Oyster card saves 50% on transportation, available at stations
    - üåßÔ∏è Always carry light raincoat, weather changes quickly

    Remember: Create an itinerary that balances visual elegance with practical information. Each activity should include enough information to understand what makes it special while maintaining the clean, minimalist aesthetic.
  `,
    });

    // Generate a prompt based on trip details
    const prompt = generateItineraryPrompt(tripDetails);
    console.log("Itinerary prompt:", prompt);

    // Set generation parameters for a detailed response
    const generationConfig = {
      temperature: 0.7,
      topP: 0.85,
      topK: 40,
      maxOutputTokens: 3000,
    };

    // Generate the itinerary
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig,
    });

    const response = result.response;
    const itinerary = response.text();

    console.log("Itinerary generated successfully");

    // DEBUG: ◊î◊ì◊§◊°◊™ ◊î◊û◊°◊ú◊ï◊ú ◊î◊û◊ú◊ê ◊ú◊ß◊ï◊†◊°◊ï◊ú ◊ú◊†◊ï◊ó◊ï◊™ ◊î◊ì◊ô◊ë◊ï◊í
    console.log("========= GENERATED ITINERARY START =========");
    console.log(itinerary);
    console.log("========= GENERATED ITINERARY END =========");

    return {
      success: true,
      itinerary,
      // Add metadata for the itinerary
      metadata: {
        destination: tripDetails.vacation_location,
        duration: tripDetails.duration,
        dates: tripDetails.dates,
        generatedAt: new Date().toISOString(),
      },
    };
  } catch (error) {
    console.error("Error generating itinerary:", error);
    return {
      success: false,
      error: error.message || "Failed to generate itinerary",
    };
  }
};

/**
 * Converts a markdown itinerary string to structured JSON format
 * @param {string} itineraryString - The markdown formatted itinerary string
 * @returns {Object} - Structured JSON representation of the itinerary
 */
export const convertItineraryToJSON = (itineraryString) => {
  try {
    console.log("Converting itinerary string to JSON...");

    // Initialize the structure for our JSON format
    const itineraryJSON = {
      title: "",
      destination: "",
      duration: "",
      dates: { from: "", to: "" },
      days: [],
      additionalInfo: {
        backupPlans: [],
        tips: [],
        hiddenGems: [],
      },
      createdAt: new Date().toISOString(),
    };

    // Parse the title and basic information
    const lines = itineraryString.split("\n");
    let currentSection = null;
    let currentDay = null;
    let sectionContent = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Skip empty lines
      if (!line) continue;

      // Extract title if it's one of the first lines (usually the first heading)
      if (line.startsWith("# ") && !itineraryJSON.title) {
        itineraryJSON.title = line.substring(2).trim();
        continue;
      }

      // Detect day headers - usually Day X: Title or Day X - Title format
      const dayMatch = line.match(/^#+\s*Day\s+(\d+)[\s:-]+(.+)$/i);
      if (dayMatch) {
        // If we were processing a previous day, save it
        if (currentDay) {
          itineraryJSON.days.push(currentDay);
        }

        // Start a new day
        currentDay = {
          dayNumber: parseInt(dayMatch[1]),
          title: dayMatch[2].trim(),
          date: "", // Will try to extract this
          activities: {
            morning: [],
            lunch: [],
            afternoon: [],
            evening: [],
            dinner: [],
          },
          transportation: [],
          notes: [],
        };

        // Look for a date in the title or the next line
        const dateMatch =
          dayMatch[2].match(/\(([^)]+)\)/) ||
          (lines[i + 1] &&
            lines[i + 1].match(
              /\b\d{1,2}(st|nd|rd|th)?.*(January|February|March|April|May|June|July|August|September|October|November|December)\b|\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2}(st|nd|rd|th)?\b/i
            ));

        if (dateMatch) {
          currentDay.date = dateMatch[1] || dateMatch[0];
        }

        currentSection = null;
        continue;
      }

      // Detect section headers within a day
      if (currentDay) {
        if (
          line.match(/^#+\s*Morning/i) ||
          line.includes("üåÖ") ||
          line.includes("‚òÄÔ∏è")
        ) {
          currentSection = "morning";
          continue;
        } else if (
          line.match(/^#+\s*Lunch/i) ||
          line.includes("üç¥") ||
          line.includes("ü•™")
        ) {
          currentSection = "lunch";
          continue;
        } else if (line.match(/^#+\s*Afternoon/i) || line.includes("üåû")) {
          currentSection = "afternoon";
          continue;
        } else if (
          line.match(/^#+\s*Evening/i) ||
          line.includes("üåô") ||
          line.includes("üåÜ")
        ) {
          currentSection = "evening";
          continue;
        } else if (
          line.match(/^#+\s*Dinner/i) ||
          line.includes("üçΩÔ∏è") ||
          line.includes("üç∑")
        ) {
          currentSection = "dinner";
          continue;
        } else if (
          line.match(/^#+\s*Transportation|Travel Tips/i) ||
          line.includes("üöå") ||
          line.includes("üöï") ||
          line.includes("üöÜ")
        ) {
          currentSection = "transportation";
          continue;
        } else if (line.match(/^#+\s*Notes/i)) {
          currentSection = "notes";
          continue;
        }

        // Process content based on current section
        if (currentSection && line.startsWith("- ")) {
          const content = line.substring(2).trim();
          if (currentSection === "transportation") {
            currentDay.transportation.push(content);
          } else if (currentSection === "notes") {
            currentDay.notes.push(content);
          } else if (currentDay.activities[currentSection]) {
            currentDay.activities[currentSection].push(content);
          }
        } else if (currentSection && line.startsWith("* ")) {
          const content = line.substring(2).trim();
          if (currentSection === "transportation") {
            currentDay.transportation.push(content);
          } else if (currentSection === "notes") {
            currentDay.notes.push(content);
          } else if (currentDay.activities[currentSection]) {
            currentDay.activities[currentSection].push(content);
          }
        }
      } else {
        // Handle sections after all days (backup plans, tips, hidden gems)
        if (
          line.match(/^#+\s*Backup Day|Contingency Plan|Backup Plan|Rain Day/i)
        ) {
          currentSection = "backupPlans";
          sectionContent = [];
          continue;
        } else if (line.match(/^#+\s*Tips|Useful Tips|Travel Tips/i)) {
          currentSection = "tips";
          sectionContent = [];
          continue;
        } else if (line.match(/^#+\s*Hidden Gems|Local Secrets/i)) {
          currentSection = "hiddenGems";
          sectionContent = [];
          continue;
        }

        // Add content to the appropriate section
        if (
          currentSection &&
          (line.startsWith("- ") || line.startsWith("* "))
        ) {
          const content = line.substring(2).trim();
          switch (currentSection) {
            case "backupPlans":
              itineraryJSON.additionalInfo.backupPlans.push(content);
              break;
            case "tips":
              itineraryJSON.additionalInfo.tips.push(content);
              break;
            case "hiddenGems":
              itineraryJSON.additionalInfo.hiddenGems.push(content);
              break;
          }
        }
      }
    }

    // Add the last day if we were processing one
    if (currentDay) {
      itineraryJSON.days.push(currentDay);
    }

    // Try to extract destination and duration from title or first lines
    const destinationMatch = itineraryJSON.title.match(
      /(?:for|in|to)\s+([^:,]+)/i
    );
    if (destinationMatch) {
      itineraryJSON.destination = destinationMatch[1].trim();
    }

    const durationMatch =
      itineraryJSON.title.match(/(\d+)[\s-]*(day|days)/i) ||
      itineraryString.match(/(\d+)[\s-]*(day|days)/i);
    if (durationMatch) {
      itineraryJSON.duration = `${durationMatch[1]} ${durationMatch[2]}`;
    } else {
      itineraryJSON.duration = `${itineraryJSON.days.length} days`;
    }

    // Extract dates from the text if available
    const dateRangeMatch = itineraryString.match(
      /(\d{1,2}(st|nd|rd|th)?.*(January|February|March|April|May|June|July|August|September|October|November|December).*(20\d{2}))\s*(?:to|-)\s*(\d{1,2}(st|nd|rd|th)?.*(January|February|March|April|May|June|July|August|September|October|November|December).*(20\d{2}))/i
    );
    if (dateRangeMatch) {
      itineraryJSON.dates.from = dateRangeMatch[1];
      itineraryJSON.dates.to = dateRangeMatch[5];
    }

    console.log("Conversion to JSON complete:", itineraryJSON);
    return itineraryJSON;
  } catch (error) {
    console.error("Error converting itinerary to JSON:", error);
    // Return a simplified JSON with the original string if conversion fails
    return {
      title: "Itinerary",
      originalText: itineraryString,
      days: [],
      error: error.message,
      conversionFailed: true,
      createdAt: new Date().toISOString(),
    };
  }
};

/**
 * Save an itinerary to the backend
 * @param {string} chatId - The chat ID to associate with this itinerary
 * @param {Object} itineraryData - The generated itinerary data
 * @returns {Promise<Object>} - API response
 */
export const saveItinerary = async (chatId, itineraryData) => {
  try {
    console.log("Saving itinerary for chat:", chatId);

    // Get authentication token if available
    let headers = { "Content-Type": "application/json" };
    try {
      // Use clerk-js directly in this utility function
      const Clerk = window.Clerk;
      if (Clerk?.session) {
        const token = await Clerk.session.getToken();
        headers["Authorization"] = `Bearer ${token}`;
      }
    } catch (authError) {
      console.warn("Auth not available for itinerary save:", authError);
    }

    // Get the current user ID
    const userId = window.Clerk?.user?.id || localStorage.getItem("userId");

    // ◊î◊û◊®◊™ ◊ô◊ï◊û◊ü ◊î◊ò◊ô◊ï◊ú ◊ú◊û◊ë◊†◊î JSON ◊ê◊ù ◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊ë◊ï◊¶◊¢◊î ◊î◊û◊®◊î
    const structuredItinerary =
      itineraryData.structuredItinerary ||
      convertItineraryToJSON(itineraryData.itinerary);

    console.log("Sending itinerary to be saved in the new Itinerary model");

    const response = await fetch(
      `${import.meta.env.VITE_API_URL}/api/itineraries?userId=${userId}`,
      {
        method: "POST",
        credentials: "include",
        headers,
        body: JSON.stringify({
          chatId,
          itinerary: itineraryData.itinerary, // Original string content
          structuredItinerary, // JSON structure
          metadata: {
            ...(itineraryData.metadata || {}),
            savedAt: new Date().toISOString(),
          },
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to save itinerary: ${response.status}`);
    }

    const result = await response.json();
    console.log("Itinerary saved successfully with ID:", result.itineraryId);
    return {
      success: true,
      itineraryId: result.itineraryId,
      ...result,
    };
  } catch (error) {
    console.error("Error saving itinerary:", error);
    return { success: false, error: error.message };
  }
};

/**
 * ◊ë◊ì◊ô◊ß◊î ◊î◊ê◊ù ◊ú◊¶'◊ê◊ò ◊ô◊© ◊õ◊ë◊® ◊ô◊ï◊û◊ü ◊û◊°◊¢ ◊ß◊ô◊ô◊ù
 * @param {string} chatId - ◊û◊ñ◊î◊î ◊î◊¶'◊ê◊ò ◊ú◊ë◊ì◊ô◊ß◊î
 * @returns {Promise<Object>} - ◊™◊ï◊¶◊ê◊™ ◊î◊ë◊ì◊ô◊ß◊î ◊¢◊ù ◊§◊®◊ò◊ô ◊î◊ô◊ï◊û◊ü ◊ê◊ù ◊ß◊ô◊ô◊ù
 */
export const checkForExistingItinerary = async (chatId) => {
  try {
    if (!chatId) {
      console.warn("No chatId provided to check for existing itinerary");
      return { exists: false };
    }

    console.log("Checking for existing itinerary for chat:", chatId);

    // ◊î◊õ◊†◊™ ◊î◊õ◊ï◊™◊®◊ï◊™ ◊ú◊ë◊ß◊©◊î
    let headers = { "Content-Type": "application/json" };
    try {
      // ◊©◊ô◊û◊ï◊© ◊ë-Clerk ◊ú◊ß◊ë◊ú◊™ ◊ò◊ï◊ß◊ü ◊ê◊ï◊™◊†◊ò◊ô◊ß◊¶◊ô◊î
      const Clerk = window.Clerk;
      if (Clerk?.session) {
        const token = await Clerk.session.getToken();
        headers["Authorization"] = `Bearer ${token}`;
      }
    } catch (authError) {
      console.warn("Auth not available for itinerary check:", authError);
    }

    // ◊ß◊ë◊ú◊™ ◊û◊ñ◊î◊î ◊î◊û◊©◊™◊û◊©
    const userId = window.Clerk?.user?.id || localStorage.getItem("userId");

    // ◊©◊ú◊ô◊ó◊™ ◊ë◊ß◊©◊î ◊ú◊©◊®◊™ ◊ú◊ë◊ì◊ô◊ß◊™ ◊ô◊ï◊û◊ü ◊ß◊ô◊ô◊ù
    const response = await fetch(
      `${
        import.meta.env.VITE_API_URL
      }/api/itineraries/check?chatId=${chatId}&userId=${userId}`,
      {
        method: "GET",
        credentials: "include",
        headers,
      }
    );

    if (!response.ok) {
      console.warn(
        `Failed to check for existing itinerary: ${response.status}`
      );
      return { exists: false };
    }

    const result = await response.json();

    if (result.exists) {
      console.log("Found existing itinerary:", result.itineraryId);
      return {
        exists: true,
        itineraryId: result.itineraryId,
        metadata: result.metadata || {},
        destination: result.metadata?.destination,
      };
    }

    return { exists: false };
  } catch (error) {
    console.error("Error checking for existing itinerary:", error);
    return { exists: false, error: error.message };
  }
};

/**
 * ◊ó◊ô◊ú◊ï◊• ◊û◊ô◊ì◊¢ ◊¢◊ú ◊ô◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô ◊û◊ô◊ï◊û◊ü ◊û◊°◊¢
 * @param {Object} structuredItinerary - ◊ô◊ï◊û◊ü ◊û◊°◊¢ ◊ë◊û◊ë◊†◊î JSON ◊û◊ï◊ë◊†◊î
 * @param {string} dayIdentifier - ◊û◊ñ◊î◊î ◊î◊ô◊ï◊ù (◊ú◊û◊©◊ú "first day", "day 2", ◊ï◊õ◊ï')
 * @returns {Object} - ◊û◊ô◊ì◊¢ ◊¢◊ú ◊î◊ô◊ï◊ù ◊î◊û◊ë◊ï◊ß◊©
 */
export const extractDayInfoFromItinerary = (
  structuredItinerary,
  dayIdentifier
) => {
  if (!structuredItinerary || !structuredItinerary.days || !dayIdentifier) {
    return null;
  }

  // ◊î◊û◊®◊™ ◊û◊ñ◊î◊î ◊î◊ô◊ï◊ù ◊ú◊û◊°◊§◊® ◊ô◊ï◊ù (1-based)
  let dayIndex = -1;
  dayIdentifier = dayIdentifier.toLowerCase().trim();

  // ◊ó◊ô◊§◊ï◊© ◊î◊™◊ê◊û◊ï◊™ ◊¢◊ù ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊©◊ï◊†◊ï◊™
  if (
    dayIdentifier === "first day" ||
    dayIdentifier === "day 1" ||
    dayIdentifier === "◊î◊ô◊ï◊ù ◊î◊®◊ê◊©◊ï◊ü" ||
    dayIdentifier === "◊ô◊ï◊ù 1" ||
    dayIdentifier === "◊ô◊ï◊ù ◊®◊ê◊©◊ï◊ü ◊ë◊ò◊ô◊ï◊ú" ||
    dayIdentifier === "first"
  ) {
    dayIndex = 0; // 0-based array index for first day
  } else if (
    dayIdentifier === "last day" ||
    dayIdentifier === "◊î◊ô◊ï◊ù ◊î◊ê◊ó◊®◊ï◊ü" ||
    dayIdentifier === "final day" ||
    dayIdentifier === "last"
  ) {
    dayIndex = structuredItinerary.days.length - 1;
  } else if (
    dayIdentifier.includes("second day") ||
    dayIdentifier.includes("day 2") ||
    dayIdentifier.includes("◊î◊ô◊ï◊ù ◊î◊©◊†◊ô") ||
    dayIdentifier.includes("◊ô◊ï◊ù 2")
  ) {
    dayIndex = 1; // 0-based array index for second day
  } else if (
    dayIdentifier.includes("third day") ||
    dayIdentifier.includes("day 3") ||
    dayIdentifier.includes("◊î◊ô◊ï◊ù ◊î◊©◊ú◊ô◊©◊ô") ||
    dayIdentifier.includes("◊ô◊ï◊ù 3")
  ) {
    dayIndex = 2; // 0-based array index for third day
  } else {
    // ◊ó◊ô◊§◊ï◊© ◊û◊°◊§◊® ◊ô◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô ◊ë◊ò◊ß◊°◊ò
    const dayNumberMatch =
      dayIdentifier.match(/day\s+(\d+)/i) || dayIdentifier.match(/◊ô◊ï◊ù\s+(\d+)/);

    if (dayNumberMatch && dayNumberMatch[1]) {
      const dayNumber = parseInt(dayNumberMatch[1], 10);
      if (
        !isNaN(dayNumber) &&
        dayNumber > 0 &&
        dayNumber <= structuredItinerary.days.length
      ) {
        dayIndex = dayNumber - 1; // ◊î◊û◊®◊î ◊ú-0-based index
      }
    }
  }

  if (dayIndex === -1 || dayIndex >= structuredItinerary.days.length) {
    console.warn(`Could not find day matching identifier: ${dayIdentifier}`);
    return null;
  }

  // ◊ó◊ô◊ú◊ï◊• ◊î◊û◊ô◊ì◊¢ ◊¢◊ú ◊î◊ô◊ï◊ù ◊î◊û◊ë◊ï◊ß◊©
  const day = structuredItinerary.days[dayIndex];

  // Get year from itinerary data - check multiple sources
  let tripYear = null;

  // Try to get year from trip metadata
  if (structuredItinerary.dates && structuredItinerary.dates.from) {
    const dateMatch = structuredItinerary.dates.from.match(/(\d{4})/);
    if (dateMatch) {
      tripYear = parseInt(dateMatch[1], 10);
      console.log(`Found year ${tripYear} in itinerary dates metadata`);
    }
  }

  // If no year found, check in the actual itinerary text
  if (!tripYear && structuredItinerary.originalText) {
    const yearMatch =
      structuredItinerary.originalText.match(/\b(202\d|203\d)\b/); // Look for years like 2023, 2024, 2030, etc.
    if (yearMatch) {
      tripYear = parseInt(yearMatch[1], 10);
      console.log(`Found year ${tripYear} in itinerary text`);
    }
  }

  // As a fallback, use the destination to guess if this is a future trip
  if (!tripYear && structuredItinerary.destination) {
    // For future trips, use next year as default
    const currentYear = new Date().getFullYear();
    tripYear = currentYear + 1;
    console.log(`No year found, defaulting to future year: ${tripYear}`);
  }

  // If still no year, use current year as fallback
  if (!tripYear) {
    tripYear = new Date().getFullYear();
    console.log(
      `No year indicators found, defaulting to current year: ${tripYear}`
    );
  }

  // ◊ó◊ô◊ú◊ï◊• ◊™◊ê◊®◊ô◊ö ◊î◊ô◊ï◊ù ◊ë◊û◊ë◊†◊î YYYY-MM-DD ◊ê◊ù ◊ê◊§◊©◊®
  let formattedDate = null;
  let parsedYear = null;

  if (day.date) {
    try {
      console.log(`Extracting date from day ${dayIndex + 1}: "${day.date}"`);

      // Clean up the date string (remove parentheses, extra spaces, etc.)
      const dateStr = day.date.replace(/\(|\)/g, "").trim();

      // First check if the date already has a complete year
      const fullDateMatch = dateStr.match(/\b(202\d|203\d)\b/); // Look for years like 2023, 2024, 2030, etc.
      if (fullDateMatch) {
        parsedYear = parseInt(fullDateMatch[1], 10);
        console.log(`Found explicit year ${parsedYear} in day date`);

        // Try parsing as full date with year
        const dateObj = new Date(dateStr);
        if (!isNaN(dateObj.getTime())) {
          formattedDate = dateObj.toISOString().split("T")[0]; // YYYY-MM-DD
          console.log(
            `Successfully parsed full date with year: ${formattedDate}`
          );
        }
      }

      // If no year in the date string itself, process month and day formats
      if (!formattedDate) {
        // Try different date formats with the extracted year from trip data
        const monthNames = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];

        // Handle cases like "June 15" by adding the year
        let monthFound = false;
        for (let i = 0; i < monthNames.length; i++) {
          if (dateStr.toLowerCase().includes(monthNames[i].toLowerCase())) {
            // Extract day number using regex
            const dayMatch = dateStr.match(/(\d{1,2})(st|nd|rd|th)?/);
            if (dayMatch) {
              const dayNum = dayMatch[1];
              const month = i + 1; // 1-based month

              // Create date string in YYYY-MM-DD format
              const fullDateStr = `${tripYear}-${month
                .toString()
                .padStart(2, "0")}-${dayNum.toString().padStart(2, "0")}`;
              console.log(
                `Reconstructed date with year: ${fullDateStr} from "${dateStr}"`
              );
              formattedDate = fullDateStr;
              monthFound = true;
              break;
            }
          }
        }

        // If we didn't find a month name, try other formats
        if (!monthFound && !formattedDate) {
          // Try format like "15/06" or "15-06" (day/month)
          const shortDateMatch = dateStr.match(/(\d{1,2})[\/\-\.](\d{1,2})/);
          if (shortDateMatch) {
            // Assuming day/month format
            const day = parseInt(shortDateMatch[1], 10);
            const month = parseInt(shortDateMatch[2], 10);

            // Only proceed if the numbers look like valid day/month
            if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {
              formattedDate = `${tripYear}-${month
                .toString()
                .padStart(2, "0")}-${day.toString().padStart(2, "0")}`;
              console.log(
                `Parsed day/month format with year: ${formattedDate}`
              );
            }
          }
        }
      }

      // If still no formatted date, try adding year to original string
      if (!formattedDate) {
        // Try with the trip year we determined
        const dateWithYear = `${dateStr}, ${tripYear}`;
        const dateObj = new Date(dateWithYear);

        if (!isNaN(dateObj.getTime())) {
          formattedDate = dateObj.toISOString().split("T")[0]; // YYYY-MM-DD
          console.log(`Added trip year and parsed: ${formattedDate}`);
        } else {
          // ◊ê◊ù ◊î◊î◊û◊®◊î ◊†◊õ◊©◊ú◊î, ◊î◊©◊™◊û◊© ◊ë◊™◊ê◊®◊ô◊ö ◊î◊û◊ß◊ï◊®◊ô
          formattedDate = dateStr;
          console.log(
            `Could not parse date: ${dateStr}, using original string`
          );
        }
      }
    } catch (e) {
      console.warn(
        `Could not parse date from day ${dayIndex + 1}:`,
        day.date,
        e
      );
      formattedDate = day.date;
    }
  } else {
    // If no date in the day object, calculate it based on the trip's start date
    try {
      if (structuredItinerary.dates && structuredItinerary.dates.from) {
        const startDate = new Date(structuredItinerary.dates.from);
        if (!isNaN(startDate.getTime())) {
          // Calculate date by adding dayIndex days to start date
          const dayDate = new Date(startDate);
          dayDate.setDate(startDate.getDate() + dayIndex);
          formattedDate = dayDate.toISOString().split("T")[0];
          parsedYear = dayDate.getFullYear();
          console.log(
            `Calculated date for day ${
              dayIndex + 1
            } from trip start date: ${formattedDate}`
          );
        }
      }
    } catch (e) {
      console.warn(`Failed to calculate date for day ${dayIndex + 1}:`, e);
    }
  }

  // Extract specific year from the formatted date if we have it
  if (formattedDate && formattedDate.includes("-") && !parsedYear) {
    const yearMatch = formattedDate.match(/^(\d{4})/);
    if (yearMatch) {
      parsedYear = parseInt(yearMatch[1], 10);
    }
  }

  // ◊ô◊ô◊¶◊ï◊® ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊™◊©◊ï◊ë◊î ◊¢◊ù ◊õ◊ú ◊î◊û◊ô◊ì◊¢ ◊î◊®◊ú◊ï◊ï◊†◊ò◊ô
  return {
    dayNumber: dayIndex + 1,
    date: formattedDate || day.date,
    title: day.title,
    activities: day.activities,
    // ◊î◊©◊™◊û◊© ◊ë◊ô◊¢◊ì ◊î◊ò◊ô◊ï◊ú ◊û◊î◊û◊ò◊ê-◊ì◊ê◊ò◊î ◊ê◊ï ◊û◊î◊õ◊ï◊™◊®◊™
    location: structuredItinerary.destination,
    // Include the year explicitly if we found it
    year: parsedYear || tripYear,
  };
};

/**
 * ◊ë◊ì◊ô◊ß◊î ◊ê◊ù ◊î◊©◊ê◊ú◊î ◊î◊ô◊ê ◊ë◊ß◊©◊™ ◊û◊ô◊ì◊¢ ◊ú◊ê◊ó◊® ◊ô◊¶◊ô◊®◊™ ◊ô◊ï◊û◊ü
 * ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ñ◊ï ◊û◊ñ◊î◊î ◊ê◊ù ◊î◊©◊ê◊ú◊î ◊î◊ô◊ê ◊ë◊ß◊©◊î ◊ú◊û◊ô◊ì◊¢ ◊ó◊ô◊¶◊ï◊†◊ô ◊õ◊û◊ï ◊û◊ñ◊í ◊ê◊ï◊ï◊ô◊®, ◊û◊ú◊ï◊†◊ï◊™ ◊ï◊õ◊ï'
 * @param {string} question - ◊î◊©◊ê◊ú◊î ◊©◊î◊û◊©◊™◊û◊© ◊©◊ê◊ú
 * @param {Object} tripContext - ◊î◊ß◊ï◊†◊ò◊ß◊°◊ò ◊©◊ú ◊î◊ô◊ï◊û◊ü ◊î◊ß◊ô◊ô◊ù
 * @returns {Object} - ◊™◊ï◊¶◊ê◊™ ◊î◊†◊ô◊™◊ï◊ó
 */
export const analyzePostItineraryQuestion = (question, tripContext) => {
  if (!question || !tripContext) {
    return { isAdviceQuestion: false };
  }

  console.log("Analyzing post-itinerary question:", question);
  console.log("Itinerary context:", tripContext);

  // ◊®◊©◊ô◊û◊™ ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊ú◊ñ◊ô◊î◊ï◊ô ◊©◊ê◊ú◊ï◊™ ◊û◊ô◊ì◊¢
  const weatherKeywords = [
    "weather",
    "◊û◊ñ◊í ◊ê◊ï◊ï◊ô◊®",
    "◊û◊ñ◊í-◊ê◊ï◊ï◊ô◊®",
    "◊í◊©◊ù",
    "◊©◊û◊©",
    "◊ò◊û◊§◊®◊ò◊ï◊®◊î",
    "◊ô◊î◊ô◊î ◊ó◊ù",
    "◊ß◊®",
    "◊™◊ó◊ñ◊ô◊™",
  ];

  const hotelsKeywords = [
    "hotel",
    "◊û◊ú◊ï◊ü",
    "◊û◊ú◊ï◊†◊ï◊™",
    "◊ú◊ô◊†◊î",
    "◊ê◊õ◊°◊†◊ô◊î",
    "◊ú◊î◊™◊ê◊®◊ó",
    "◊ú◊ô◊©◊ï◊ü",
    "◊ú◊ú◊ï◊ü",
    "booking",
    "◊ê◊ô◊®◊ë◊†◊ë",
    "airbnb",
  ];

  const restaurantsKeywords = [
    "restaurant",
    "◊û◊°◊¢◊ì◊î",
    "◊û◊°◊¢◊ì◊ï◊™",
    "◊ê◊ï◊õ◊ú",
    "◊ú◊ê◊õ◊ï◊ú",
    "◊ê◊®◊ï◊ó◊î",
    "dining",
    "eat",
    "food",
  ];

  const attractionsKeywords = [
    "attractions",
    "◊ê◊ò◊®◊ß◊¶◊ô◊ï◊™",
    "◊û◊î ◊ú◊¢◊©◊ï◊™",
    "◊û◊ß◊ï◊û◊ï◊™",
    "◊û◊ï◊ñ◊ô◊ê◊ï◊ü",
    "museum",
    "site",
    "park",
    "◊§◊ê◊®◊ß",
  ];

  const transportKeywords = [
    "transportation",
    "◊™◊ó◊ë◊ï◊®◊î",
    "◊ê◊ï◊ò◊ï◊ë◊ï◊°",
    "◊®◊õ◊ë◊™",
    "◊û◊ò◊®◊ï",
    "taxi",
    "◊û◊ï◊†◊ô◊™",
    "bus",
    "train",
    "transport",
  ];

  // ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊ú◊ñ◊ô◊î◊ï◊ô ◊ô◊û◊ô◊ù ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù ◊ë◊ô◊ï◊û◊ü
  const dayIdentifierKeywords = [
    "first day",
    "day 1",
    "second day",
    "day 2",
    "third day",
    "day 3",
    "last day",
    "final day",
    "◊ô◊ï◊ù ◊®◊ê◊©◊ï◊ü",
    "◊ô◊ï◊ù 1",
    "◊ô◊ï◊ù ◊©◊†◊ô",
    "◊ô◊ï◊ù 2",
    "◊î◊ô◊ï◊ù ◊î◊®◊ê◊©◊ï◊ü",
    "◊î◊ô◊ï◊ù ◊î◊©◊†◊ô",
    "◊î◊ô◊ï◊ù ◊î◊ê◊ó◊®◊ï◊ü",
    "day one",
    "day two",
    "trip day",
    "◊ô◊ï◊ù ◊ò◊ô◊ï◊ú",
    "◊ô◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô",
    "specific day",
  ];

  // ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊¢◊ù ◊û◊°◊§◊®◊ô◊ù ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù ◊ú◊ô◊û◊ô◊ù
  const ordinalDayIdentifiers = [
    "1st day",
    "2nd day",
    "3rd day",
    "4th day",
    "5th day",
    "first",
    "second",
    "third",
    "fourth",
    "fifth",
    "◊®◊ê◊©◊ï◊ü",
    "◊©◊†◊ô",
    "◊©◊ú◊ô◊©◊ô",
    "◊®◊ë◊ô◊¢◊ô",
    "◊ó◊û◊ô◊©◊ô",
  ];

  const questionLower = question.toLowerCase();

  // ◊ë◊ì◊ô◊ß◊î ◊ê◊ù ◊î◊©◊ê◊ú◊î ◊û◊õ◊ô◊ú◊î ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊û◊ê◊ó◊™ ◊î◊ß◊ò◊í◊ï◊®◊ô◊ï◊™
  const isWeatherQuestion = weatherKeywords.some((keyword) =>
    questionLower.includes(keyword)
  );
  const isHotelQuestion = hotelsKeywords.some((keyword) =>
    questionLower.includes(keyword)
  );
  const isRestaurantQuestion = restaurantsKeywords.some((keyword) =>
    questionLower.includes(keyword)
  );
  const isAttractionQuestion = attractionsKeywords.some((keyword) =>
    questionLower.includes(keyword)
  );
  const isTransportQuestion = transportKeywords.some((keyword) =>
    questionLower.includes(keyword)
  );

  // ◊ó◊ô◊§◊ï◊© ◊î◊™◊ô◊ô◊ó◊°◊ï◊™ ◊ú◊ô◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô ◊ë◊ô◊ï◊û◊ü
  let hasDayIdentifier = false;
  let specificDay = null;

  // ◊ó◊ô◊§◊ï◊© ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊®◊í◊ô◊ú◊ï◊™ ◊ú◊ô◊û◊ô◊ù
  for (const keyword of dayIdentifierKeywords) {
    if (questionLower.includes(keyword)) {
      hasDayIdentifier = true;
      specificDay = keyword;
      console.log(`Found day identifier: ${keyword}`);
      break;
    }
  }

  // ◊ó◊ô◊§◊ï◊© ◊û◊°◊§◊® ◊ô◊ï◊ù ◊ë◊û◊©◊§◊ò ◊ê◊ù ◊ú◊ê ◊†◊û◊¶◊ê ◊¢◊ì◊ô◊ô◊ü
  if (!hasDayIdentifier) {
    // ◊ó◊ô◊§◊ï◊© ◊û◊©◊§◊ò◊ô◊ù ◊õ◊û◊ï "on day 2" ◊ê◊ï "day 3 of my trip"
    const dayMatches = [
      ...questionLower.matchAll(
        /(?:on|for|about|during|in)?\s*(?:the)?\s*day\s+(\d+)/gi
      ),
      ...questionLower.matchAll(/◊ô◊ï◊ù\s+(\d+)/g),
    ];

    if (dayMatches.length > 0) {
      const dayNumber = dayMatches[0][1];
      specificDay = `day ${dayNumber}`;
      hasDayIdentifier = true;
      console.log(`Found day number match: ${specificDay}`);
    }

    // ◊ó◊ô◊§◊ï◊© ◊ë◊ô◊ò◊ï◊ô◊ô◊ù ◊°◊ô◊ì◊ï◊®◊ô◊ô◊ù ◊õ◊û◊ï "second day" ◊ê◊ù ◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊†◊û◊¶◊ê
    if (!hasDayIdentifier) {
      for (const ordinal of ordinalDayIdentifiers) {
        if (questionLower.includes(ordinal)) {
          specificDay = ordinal;
          hasDayIdentifier = true;
          console.log(`Found ordinal day identifier: ${ordinal}`);

          // ◊î◊û◊®◊™ ◊û◊°◊§◊®◊ô◊ù ◊°◊ô◊ì◊ï◊®◊ô◊ô◊ù ◊ú◊§◊ï◊®◊û◊ò ◊ô◊ï◊ù
          if (ordinal === "first" || ordinal === "◊®◊ê◊©◊ï◊ü") specificDay = "day 1";
          else if (ordinal === "second" || ordinal === "◊©◊†◊ô")
            specificDay = "day 2";
          else if (ordinal === "third" || ordinal === "◊©◊ú◊ô◊©◊ô")
            specificDay = "day 3";
          else if (ordinal === "fourth" || ordinal === "◊®◊ë◊ô◊¢◊ô")
            specificDay = "day 4";
          else if (ordinal === "fifth" || ordinal === "◊ó◊û◊ô◊©◊ô")
            specificDay = "day 5";
          else if (ordinal === "1st day") specificDay = "day 1";
          else if (ordinal === "2nd day") specificDay = "day 2";
          else if (ordinal === "3rd day") specificDay = "day 3";
          else if (ordinal === "4th day") specificDay = "day 4";
          else if (ordinal === "5th day") specificDay = "day 5";
          break;
        }
      }
    }
  }

  // ◊ñ◊ô◊î◊ï◊ô ◊î◊ß◊ò◊í◊ï◊®◊ô◊î ◊î◊û◊™◊ê◊ô◊û◊î
  let adviceType = null;
  let intent = null;

  if (isWeatherQuestion) {
    adviceType = "weather";
    intent = "Weather-Request";
  } else if (isHotelQuestion) {
    adviceType = "hotels";
    intent = "Find-Hotel";
  } else if (isRestaurantQuestion) {
    adviceType = "restaurants";
    intent = "Find-Restaurants";
  } else if (isAttractionQuestion) {
    adviceType = "attractions";
    intent = "Find-Attractions";
  } else if (isTransportQuestion) {
    adviceType = "transportation";
    intent = "Public-Transport-Info";
  }

  // ◊ê◊ù ◊ñ◊ï◊î◊™◊î ◊©◊ê◊ú◊™ ◊û◊ô◊ì◊¢ ◊õ◊ú◊©◊î◊ô
  const isAdviceQuestion = adviceType !== null;

  // ◊û◊ô◊ì◊¢ ◊û◊ô◊ß◊ï◊ù ◊ë◊°◊ô◊°◊ô ◊û◊ô◊¢◊ì ◊î◊ò◊ô◊ï◊ú
  let locationInfo = {};
  if (tripContext.vacation_location) {
    // ◊†◊ô◊°◊ô◊ï◊ü ◊ú◊§◊¶◊ú ◊ê◊™ ◊î◊û◊ô◊ß◊ï◊ù ◊ú◊¢◊ô◊® ◊ï◊û◊ì◊ô◊†◊î
    const locationParts = tripContext.vacation_location
      .split(",")
      .map((part) => part.trim());
    if (locationParts.length >= 2) {
      locationInfo = {
        city: locationParts[0],
        country: locationParts[1],
      };
    } else {
      locationInfo = {
        location: tripContext.vacation_location,
      };
    }
  }

  // ◊ë◊ì◊ô◊ß◊î ◊ê◊ù ◊ô◊© ◊û◊ë◊†◊î ◊û◊°◊ú◊ï◊ú ◊û◊ê◊ï◊®◊í◊ü
  if (!tripContext.structuredItinerary) {
    console.log("No structured itinerary found in trip context");

    // ◊†◊ô◊°◊ô◊ï◊ü ◊ú◊ó◊ú◊• ◊û◊°◊ú◊ï◊ú ◊û◊ï◊ë◊†◊î ◊û◊î◊û◊ó◊®◊ï◊ñ◊™ ◊©◊ú ◊î◊ô◊ï◊û◊ü ◊ê◊ù ◊ô◊©
    if (tripContext.itinerary && typeof tripContext.itinerary === "string") {
      try {
        console.log("Attempting to extract structured itinerary from text");
        tripContext.structuredItinerary = convertItineraryToJSON(
          tripContext.itinerary
        );
      } catch (e) {
        console.error("Failed to convert itinerary to JSON:", e);
      }
    }
  }

  // ◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£ ◊û◊ô◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô ◊ë◊ô◊ï◊û◊ü ◊î◊û◊°◊¢
  let dayInfo = null;
  if (hasDayIdentifier && tripContext.structuredItinerary) {
    console.log("Extracting info for day:", specificDay);
    console.log("From structured itinerary:", tripContext.structuredItinerary);
    dayInfo = extractDayInfoFromItinerary(
      tripContext.structuredItinerary,
      specificDay
    );
    console.log(`Found day info for ${specificDay}:`, dayInfo);
  } else if (hasDayIdentifier) {
    console.log("Day identifier found but no structured itinerary available");
  }

  // ◊©◊ô◊ú◊ï◊ë ◊î◊û◊ô◊ì◊¢ ◊û◊î◊ô◊ï◊ù ◊î◊°◊§◊¶◊ô◊§◊ô ◊¢◊ù ◊û◊ô◊ì◊¢ ◊î◊û◊ô◊ß◊ï◊ù ◊î◊ë◊°◊ô◊°◊ô
  let enhancedLocationInfo = { ...locationInfo };

  // ◊î◊ï◊°◊§◊™ ◊™◊ê◊®◊ô◊ö ◊°◊§◊¶◊ô◊§◊ô ◊ê◊ù ◊†◊û◊¶◊ê
  if (dayInfo && dayInfo.date) {
    enhancedLocationInfo.date = dayInfo.date;
    enhancedLocationInfo.time = dayInfo.date; // ◊ú◊ò◊ï◊ë◊™ ◊ë◊ß◊©◊™ ◊û◊ñ◊í ◊ê◊ï◊ï◊ô◊®

    if (intent === "Weather-Request") {
      // ◊ú◊î◊í◊ì◊ô◊® ◊ê◊™ timeContext ◊ú◊§◊ô ◊î◊©◊ï◊ï◊ê◊™ ◊î◊™◊ê◊®◊ô◊ö ◊ú◊™◊ê◊®◊ô◊ö ◊î◊†◊ï◊õ◊ó◊ô
      try {
        const dayDate = new Date(dayInfo.date);
        const today = new Date();
        today.setHours(0, 0, 0, 0); // ◊ê◊§◊° ◊ê◊™ ◊î◊©◊¢◊î ◊ú◊î◊©◊ï◊ï◊ê◊™ ◊™◊ê◊®◊ô◊õ◊ô◊ù ◊ë◊ú◊ë◊ì

        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);

        if (dayDate.toDateString() === today.toDateString()) {
          enhancedLocationInfo.timeContext = "today";
          enhancedLocationInfo.isToday = true;
        } else if (dayDate.toDateString() === tomorrow.toDateString()) {
          enhancedLocationInfo.timeContext = "tomorrow";
          enhancedLocationInfo.isTomorrow = true;
        } else {
          enhancedLocationInfo.timeContext = "specific_date";
        }
      } catch (e) {
        console.warn("Error comparing dates:", e);
      }
    }
  } else if (hasDayIdentifier && specificDay && intent === "Weather-Request") {
    // ◊ê◊ù ◊ê◊ô◊ü ◊™◊ê◊®◊ô◊ö ◊û◊§◊ï◊®◊© ◊ê◊ë◊ú ◊ô◊© ◊ô◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô, ◊†◊°◊î ◊ú◊û◊¶◊ï◊ê ◊ê◊ï ◊ú◊ó◊©◊ë ◊™◊ê◊®◊ô◊ö
    const today = new Date();

    // ◊ó◊ô◊ú◊ï◊• ◊û◊ô◊ì◊¢ ◊û◊î◊û◊°◊§◊® ◊©◊ú ◊î◊ô◊ï◊ù ◊î◊û◊ë◊ï◊ß◊©
    let dayNumber = 1;

    if (
      specificDay.includes("1") ||
      specificDay.includes("one") ||
      specificDay.includes("first")
    ) {
      dayNumber = 1;
    } else if (
      specificDay.includes("2") ||
      specificDay.includes("two") ||
      specificDay.includes("second")
    ) {
      dayNumber = 2;
    } else if (
      specificDay.includes("3") ||
      specificDay.includes("three") ||
      specificDay.includes("third")
    ) {
      dayNumber = 3;
    } else if (
      specificDay.includes("4") ||
      specificDay.includes("four") ||
      specificDay.includes("fourth")
    ) {
      dayNumber = 4;
    } else if (
      specificDay.includes("5") ||
      specificDay.includes("five") ||
      specificDay.includes("fifth")
    ) {
      dayNumber = 5;
    }

    console.log(`Using calculated day number: ${dayNumber} for ${specificDay}`);

    // ◊ó◊ô◊©◊ï◊ë ◊î◊™◊ê◊®◊ô◊ö ◊ú◊§◊ô ◊û◊°◊§◊® ◊î◊ô◊û◊ô◊ù ◊û◊î◊ô◊ï◊ù ◊î◊®◊ê◊©◊ï◊ü ◊©◊ú ◊î◊ò◊ô◊ï◊ú
    let startDate = null;

    // ◊†◊°◊î ◊ú◊û◊¶◊ï◊ê ◊ê◊™ ◊î◊ô◊ï◊ù ◊î◊®◊ê◊©◊ï◊ü ◊û◊™◊ê◊®◊ô◊õ◊ô ◊î◊ò◊ô◊ï◊ú
    if (tripContext.dates && tripContext.dates.from) {
      startDate = new Date(tripContext.dates.from);
    } else if (
      tripContext.structuredItinerary &&
      tripContext.structuredItinerary.days &&
      tripContext.structuredItinerary.days[0] &&
      tripContext.structuredItinerary.days[0].date
    ) {
      startDate = new Date(tripContext.structuredItinerary.days[0].date);
    }

    // Try harder to find the trip dates from global context if available
    if (!startDate || isNaN(startDate.getTime())) {
      // Try to find the start date from tripContext metadata
      if (
        tripContext.metadata &&
        tripContext.metadata.dates &&
        tripContext.metadata.dates.from
      ) {
        try {
          startDate = new Date(tripContext.metadata.dates.from);
          console.log(
            `Using trip start date from metadata: ${
              startDate.toISOString().split("T")[0]
            }`
          );
        } catch (e) {
          console.warn("Error parsing metadata date:", e);
        }
      }

      // If still no valid date, look at the first day of the structured itinerary more carefully
      if (
        (!startDate || isNaN(startDate.getTime())) &&
        tripContext.structuredItinerary &&
        tripContext.structuredItinerary.days &&
        tripContext.structuredItinerary.days[0]
      ) {
        const firstDayDate = tripContext.structuredItinerary.days[0].date;
        if (firstDayDate) {
          // Try to extract a full date with year
          try {
            // Check if the title or content has year information
            let yearMatch = null;
            if (tripContext.itinerary) {
              yearMatch = tripContext.itinerary.match(/202\d/); // Find first year like 2023, 2024, etc.
            }

            const firstDayDateStr = firstDayDate.replace(/\(|\)/g, "").trim();
            let modifiedDateStr = firstDayDateStr;

            // If we found a year in the itinerary, add it to the date string
            if (yearMatch && yearMatch[0]) {
              modifiedDateStr = `${firstDayDateStr} ${yearMatch[0]}`;
              console.log(
                `Adding year ${yearMatch[0]} found in itinerary to ${firstDayDateStr}`
              );
            }

            startDate = new Date(modifiedDateStr);

            // If that didn't work, try more formats
            if (isNaN(startDate.getTime())) {
              // Try month name formats
              const monthNames = [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
              ];

              for (let i = 0; i < monthNames.length; i++) {
                if (firstDayDateStr.includes(monthNames[i])) {
                  const dayMatch = firstDayDateStr.match(
                    /(\d{1,2})(st|nd|rd|th)?/
                  );
                  if (dayMatch) {
                    const dayNum = parseInt(dayMatch[1]);
                    const month = i + 1;
                    const year = yearMatch
                      ? parseInt(yearMatch[0])
                      : new Date().getFullYear();

                    startDate = new Date(year, month - 1, dayNum);
                    console.log(
                      `Parsed first day date using month name: ${
                        startDate.toISOString().split("T")[0]
                      }`
                    );
                    break;
                  }
                }
              }
            }
          } catch (e) {
            console.warn("Error parsing first day date:", e);
          }
        }
      }

      // If all else fails, default to today's date
      if (!startDate || isNaN(startDate.getTime())) {
        console.log("No valid start date found, using today's date");
        startDate = today;
      }
    }

    // ◊ó◊ô◊©◊ï◊ë ◊î◊™◊ê◊®◊ô◊ö ◊ú◊§◊ô ◊û◊°◊§◊® ◊î◊ô◊ï◊ù
    const targetDate = new Date(startDate);
    targetDate.setDate(startDate.getDate() + (dayNumber - 1)); // -1 ◊õ◊ô ◊ô◊ï◊ù 1 ◊î◊ï◊ê ◊ô◊ï◊ù ◊î◊î◊™◊ó◊ú◊î

    // ◊î◊ï◊°◊§◊™ ◊î◊™◊ê◊®◊ô◊ö ◊î◊û◊ó◊ï◊©◊ë ◊ú◊û◊ô◊ì◊¢ ◊î◊û◊ô◊ß◊ï◊ù
    const fullDateIsoString = targetDate.toISOString().split("T")[0]; // YYYY-MM-DD
    enhancedLocationInfo.date = fullDateIsoString;
    enhancedLocationInfo.time = fullDateIsoString;

    // Add year explicitly to make sure we have complete date information
    enhancedLocationInfo.year = targetDate.getFullYear();
    console.log(
      `Setting explicit year=${enhancedLocationInfo.year} for the date`
    );

    // ◊ß◊ë◊ô◊¢◊™ timeContext ◊ú◊§◊ô ◊™◊ê◊®◊ô◊ö ◊ô◊ó◊°◊ô
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    if (targetDate.toDateString() === today.toDateString()) {
      enhancedLocationInfo.timeContext = "today";
      enhancedLocationInfo.isToday = true;
    } else if (targetDate.toDateString() === tomorrow.toDateString()) {
      enhancedLocationInfo.timeContext = "tomorrow";
      enhancedLocationInfo.isTomorrow = true;
    } else {
      enhancedLocationInfo.timeContext = "specific_date";
    }

    console.log(
      `Calculated date for day ${dayNumber}: ${enhancedLocationInfo.date} (${enhancedLocationInfo.timeContext})`
    );
  }

  // ◊û◊ô◊ì◊¢ ◊û◊ô◊ß◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô ◊û◊î◊ô◊ï◊ù ◊î◊û◊ë◊ï◊ß◊© ◊ê◊ù ◊ô◊©
  if (
    dayInfo &&
    dayInfo.location &&
    dayInfo.location !== enhancedLocationInfo.location
  ) {
    // ◊ê◊ù ◊ô◊© ◊û◊ô◊ß◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô ◊ú◊ô◊ï◊ù ◊ñ◊î, ◊î◊©◊™◊û◊© ◊ë◊ï ◊ë◊û◊ß◊ï◊ù ◊î◊û◊ô◊ß◊ï◊ù ◊î◊õ◊ú◊ú◊ô ◊©◊ú ◊î◊ò◊ô◊ï◊ú
    try {
      const dayLocationParts = dayInfo.location
        .split(",")
        .map((part) => part.trim());
      if (dayLocationParts.length >= 2) {
        enhancedLocationInfo.city = dayLocationParts[0];
        enhancedLocationInfo.country = dayLocationParts[1];
      } else {
        enhancedLocationInfo.location = dayInfo.location;
      }
    } catch (e) {
      console.warn("Error parsing day location:", e);
    }
  }

  // ◊ê◊ù ◊ú◊ê ◊î◊¶◊ú◊ó◊†◊ï ◊ú◊ó◊ú◊• ◊û◊ô◊ß◊ï◊ù ◊û◊î◊ô◊ï◊ù ◊î◊°◊§◊¶◊ô◊§◊ô, ◊†◊©◊™◊û◊© ◊ë◊û◊ô◊ß◊ï◊ù ◊î◊õ◊ú◊ú◊ô ◊©◊ú ◊î◊ò◊ô◊ï◊ú
  if (
    hasDayIdentifier &&
    !enhancedLocationInfo.city &&
    !enhancedLocationInfo.country &&
    enhancedLocationInfo.location &&
    enhancedLocationInfo.location.includes(",")
  ) {
    const parts = enhancedLocationInfo.location.split(",").map((p) => p.trim());
    if (parts.length >= 2) {
      enhancedLocationInfo.city = parts[0];
      enhancedLocationInfo.country = parts[1];
      console.log(
        `Using general location from trip: city=${parts[0]}, country=${parts[1]}`
      );
    }
  }

  // ◊ú◊ï◊í ◊†◊®◊ó◊ë ◊ú◊û◊ò◊®◊ï◊™ ◊ì◊ô◊ë◊ê◊í
  console.log("Question analysis complete");
  console.log("Is advice question:", isAdviceQuestion);
  console.log("Intent:", intent);
  console.log("Has day identifier:", hasDayIdentifier);
  console.log("Specific day:", specificDay);
  console.log("Enhanced location info:", enhancedLocationInfo);

  return {
    isAdviceQuestion,
    adviceType,
    intent,
    specificDay: hasDayIdentifier ? specificDay : null,
    dayInfo,
    locationInfo: enhancedLocationInfo, // ◊õ◊ï◊ú◊ú ◊™◊ê◊®◊ô◊ö ◊ï◊î◊ß◊©◊® ◊ñ◊û◊ü ◊ê◊ù ◊†◊û◊¶◊ê◊ï
    suggestedState: isAdviceQuestion ? "ITINERARY_ADVICE_MODE" : null,
  };
};
